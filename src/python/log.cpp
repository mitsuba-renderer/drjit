/*
    log.cpp -- Log callback that prints debug output through
    Python streams

    Dr.Jit: A Just-In-Time-Compiler for Differentiable Rendering
    Copyright 2023, Realistic Graphics Lab, EPFL.

    All rights reserved. Use of this source code is governed by a
    BSD-style license that can be found in the LICENSE.txt file.
*/

#include "log.h"

static bool running_in_jupyter_notebook = false;

#if PY_VERSION_HEX < 0x030A0000
// Emulate PyGC_Enable()/ PyGC_Disable() on Python < 3.10
static PyCFunction pygc_enable = nullptr, pygc_disable = nullptr,
                   pygc_isenabled = nullptr;

static void PyGC_Enable() {
    pygc_enable(nullptr, nullptr);
}

static int PyGC_Disable() {
    pygc_disable(nullptr, nullptr);
    PyObject *value = pygc_isenabled(nullptr, nullptr);
    long value_l = PyLong_AsLong(value);
    if (value_l != 0 && value_l != 1) {
        fprintf(stderr, "PyGC_Disable() emulation: invalid state!");
        abort();
    }
    Py_DECREF(value);
    return (int) value_l;
}
#endif

struct scoped_disable_gc {
    scoped_disable_gc() {
        status = PyGC_Disable();
    }
    ~scoped_disable_gc() {
        if (status)
            PyGC_Enable();
    }
    int status;
};

/**
 * \brief Log callback that tries to print to the Python console if possible.
 *
 * It *never* tries to acquire the GIL to avoid deadlocks and instead falls
 * back to 'stderr' if needed.
 */
static void log_callback(LogLevel level, const char *msg) {
    // If Python has already shut down and this is a debug message generated by
    // remaining Dr.Jit cleanup code (e.g. static destructors), then let's
    // route these message directly to stderr.
    if (!nb::is_alive()) {
        fputs(msg, stderr);
        fflush(stderr);
        return;
    }

    // Must hold the GIL to access the functionality below
    nb::gil_scoped_acquire guard_1;

    // Temporarily disable the GC. Otherwise we can have situations where a log
    // message printed by a function that holds the Dr.Jit mutex triggers a
    // variable deletion that tries to reacquire the (non-reentrant) Dr.Jit mutex
    scoped_disable_gc guard_2;

    // Temporarily clear error status flags, if present
    nb::error_scope guard_3;

    bool err_out = level == LogLevel::Error || level == LogLevel::Warn;
    nb::handle file;
    if (err_out)
        file = PySys_GetObject("stderr");

    nb::print(msg, nb::handle(), file);

    if (level == LogLevel::Error) {
        // If this is a fatal error that will bring down the Python process,
        // then let's ensure that the error message is properly delivered,
        // including potentially to a Jupyter notebook.
        file.attr("flush")();

        /// In case something intercepts stderr, write to the raw one as well
        nb::handle file2 = PySys_GetObject("__stderr__");
        if (!file.is(file2)) {
            nb::print(msg, nb::handle(), file2);
            file2.attr("flush")();
        }

        if (running_in_jupyter_notebook)
            nb::module_::import_("time").attr("sleep")(0.5);
    }
}

void export_log(nb::module_ &m, PyModuleDef &pmd) {
#if PY_VERSION_HEX < 0x030A0000
    // Emulate PyGC_Enable()/ PyGC_Disable() on Python < 3.10

    nb::module_ gc_module = nb::module_::import_("gc");
    nb::object f_enable  = gc_module.attr("enable"),
               f_disable = gc_module.attr("disable"),
               f_isenabled = gc_module.attr("isenabled");

    if (Py_TYPE(f_enable.ptr()) != &PyCFunction_Type ||
        Py_TYPE(f_disable.ptr()) != &PyCFunction_Type ||
        Py_TYPE(f_isenabled.ptr()) != &PyCFunction_Type ||
        PyCFunction_GET_FLAGS(f_enable.ptr()) != METH_NOARGS ||
        PyCFunction_GET_FLAGS(f_disable.ptr()) != METH_NOARGS ||
        PyCFunction_GET_FLAGS(f_isenabled.ptr()) != METH_NOARGS) {
        fprintf(stderr, "drjit: could not interface with garbage collector!");
        abort();
    }

    pygc_enable = (PyCFunction) PyCFunction_GET_FUNCTION(f_enable.ptr());
    pygc_disable = (PyCFunction) PyCFunction_GET_FUNCTION(f_disable.ptr());
    pygc_isenabled = (PyCFunction) PyCFunction_GET_FUNCTION(f_isenabled.ptr());
#endif

    nb::dict modules = nb::borrow<nb::dict>(PySys_GetObject("modules"));
    running_in_jupyter_notebook = modules.contains("ipykernel");

    jit_set_log_level_stderr(LogLevel::Disable);
    jit_set_log_level_callback(LogLevel::Warn, log_callback);

    pmd.m_free = [](void *) {
        /// Shut down the JIT when the module is deallocated
        jit_set_log_level_stderr(LogLevel::Warn);
        jit_set_log_level_callback(LogLevel::Disable, nullptr);
        jit_shutdown(false);
    };

    nb::enum_<LogLevel>(m, "LogLevel")
        .value("Disable", LogLevel::Disable)
        .value("Error", LogLevel::Error)
        .value("Warn", LogLevel::Warn)
        .value("Info", LogLevel::Info)
        .value("InfoSym", LogLevel::InfoSym)
        .value("Debug", LogLevel::Debug)
        .value("Trace", LogLevel::Trace);

    m.def("set_log_level", [](LogLevel level) {
        jit_set_log_level_callback(level, log_callback);
    });

    m.def("set_log_level", [](int level) {
        jit_set_log_level_callback((LogLevel) level, log_callback);
    });

    m.def("log_level", &jit_log_level_callback);
}
